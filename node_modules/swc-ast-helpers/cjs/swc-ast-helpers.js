'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function getKey(identifer) {
    return typeof identifer == 'string' ? createIdentifer(identifer) : identifer;
}
function createStringLiteralValue(value) {
    return typeof value == 'string' ? createStringLiteral(value) : value;
}
function createSpan(span = {
    start: 0,
    end: 0,
    ctxt: 0
}) {
    return span;
}
function createIdentifer(value) {
    const object = {
        span: createSpan(),
        type: 'Identifier',
        value,
        optional: false
    };
    return object;
}
function createStringLiteral(value) {
    const object = {
        type: 'StringLiteral',
        span: createSpan(),
        value,
        raw: `'${value}'`,
        hasEscape: false
    };
    return object;
}
function createMemberExpression(object, property) {
    const result = {
        type: 'MemberExpression',
        span: createSpan(),
        object,
        property
    };
    return result;
}
function createCallExpression(callee, args = []) {
    const object = {
        type: 'CallExpression',
        span: createSpan(),
        callee,
        arguments: args
    };
    return object;
}
function createExpressionStatement(expression) {
    const statement = {
        type: 'ExpressionStatement',
        span: createSpan(),
        expression
    };
    return statement;
}
function createAssignmentExpression(left, right) {
    const expression = {
        type: 'AssignmentExpression',
        span: createSpan(),
        operator: '=',
        left,
        right
    };
    return expression;
}
function createImportDefaultSpecifier(identifer) {
    const specifier = {
        type: 'ImportDefaultSpecifier',
        span: createSpan(),
        local: getKey(identifer)
    };
    return specifier;
}
function createImportSpecifier(identifer) {
    const specifier = {
        type: 'ImportSpecifier',
        span: createSpan(),
        local: getKey(identifer)
    };
    return specifier;
}
function createNamedImportSpecifier(local, imported) {
    return {
        ...createImportSpecifier(local),
        imported: getKey(imported)
    };
}
function createArrayExpression(elements) {
    const expression = {
        type: 'ArrayExpression',
        span: createSpan(),
        elements
    };
    return expression;
}
function createKeyValueProperty(identifer, expression) {
    const props = {
        type: 'KeyValueProperty',
        key: getKey(identifer),
        value: expression
    };
    return props;
}
function createObjectExpression(properties) {
    const argument = {
        type: 'ObjectExpression',
        span: createSpan(),
        properties
    };
    return argument;
}
function createReturnStatement(expression) {
    const statement = {
        type: 'ReturnStatement',
        span: createSpan(),
        argument: expression
    };
    return statement;
}
function createBlockStatement(statements) {
    const statement = {
        type: 'BlockStatement',
        span: createSpan(),
        stmts: statements || []
    };
    return statement;
}
function updateImportDeclaration(node, source, specifiers) {
    const imports = {
        type: 'ImportDeclaration',
        span: createSpan(),
        source,
        specifiers: [
            ...node?.specifiers || [],
            ...specifiers
        ],
        typeOnly: false,
        hasEscape: false
    };
    return imports;
}
function createThisExpression() {
    const expression = {
        type: 'ThisExpression',
        span: createSpan()
    };
    return expression;
}
function createGetter(key, body, decorators = []) {
    const expression = {
        type: 'ClassMethod',
        span: createSpan(),
        key,
        function: createFunction(body, [], decorators),
        kind: 'getter',
        is_static: false,
        is_abstract: false,
        is_optional: false,
        accessibility: null
    };
    return expression;
}
function createFunction(body, params = [], decorators = []) {
    const expression = {
        params,
        decorators,
        span: createSpan(),
        body,
        generator: false,
        async: false,
        typeParameters: null,
        returnType: null
    };
    return expression;
}
function createTemplateElement(value, isNewSyntax = false) {
    const literal = isNewSyntax ? value : createStringLiteral(value);
    const template = {
        type: 'TemplateElement',
        span: createSpan(),
        tail: true,
        cooked: literal,
        raw: literal
    };
    return template;
}
function createTemplateLiteral(quasis, expressions = []) {
    const template = {
        type: 'TemplateLiteral',
        span: createSpan(),
        expressions,
        quasis
    };
    return template;
}
function createTaggedTemplateExpression(tag, template) {
    const result = {
        type: 'TaggedTemplateExpression',
        span: createSpan(),
        tag,
        template
    };
    return result;
}
function createDecorator(expression) {
    const result = {
        type: 'Decorator',
        span: createSpan(),
        expression
    };
    return result;
}
function createClassProperty(key, value, options) {
    const property = {
        type: 'ClassProperty',
        span: createSpan(),
        key: getKey(key),
        value,
        ...options || {}
    };
    return property;
}
function createExportDefaultDeclaration(decl) {
    return {
        type: 'ExportDefaultDeclaration',
        decl
    };
}
function createClassExpression(identifer, body, decorators, superClass) {
    return {
        type: 'ClassExpression',
        span: createSpan(),
        identifier: getKey(identifer),
        body,
        decorators,
        superClass
    };
}
function createExportDefaultClassExpression(identifer, body, decorators, superClass) {
    return createExportDefaultDeclaration(createClassExpression(identifer, body, decorators, superClass));
}
function createExportDefaultExpression(expression) {
    return {
        type: 'ExportDefaultExpression',
        span: createSpan(),
        expression: getKey(expression)
    };
}
function createVariableDeclarator(id, definite, init) {
    return {
        type: 'VariableDeclarator',
        span: createSpan(),
        id: getKey(id)
    };
}
function createVariableDeclaration(kind, declare, declarations) {
    return {
        type: 'VariableDeclaration',
        span: createSpan(),
        kind,
        declare,
        declarations
    };
}
function createImportDeclaration(specifiers, source) {
    return {
        type: 'ImportDeclaration',
        span: createSpan(),
        specifiers,
        source: createStringLiteralValue(source)
    };
}
function createConstructor(body, params = []) {
    return {
        type: 'Constructor',
        span: createSpan(),
        key: createIdentifer('constructor'),
        params,
        body
    };
}
function createNullLiteral() {
    return {
        type: 'NullLiteral',
        span: createSpan()
    };
}
function createSuper(args) {
    return {
        type: 'Super',
        span: createSpan()
    };
}
function createOptionalChainingExpression(base) {
    return {
        type: 'OptionalChainingExpression',
        span: createSpan(),
        questionDotToken: createSpan(),
        base
    };
}

const TYPES = Object.freeze({
    CallExpression: 'CallExpression',
    ClassDeclaration: 'ClassDeclaration',
    Decorator: 'Decorator',
    ImportDeclaration: 'ImportDeclaration',
    StringLiteral: 'StringLiteral',
    ClassMethod: 'ClassMethod',
    Identifier: 'Identifier',
    ImportSpecifier: 'ImportSpecifier',
    MemberExpression: 'MemberExpression',
    ExpressionStatement: 'ExpressionStatement',
    ReturnStatement: 'ReturnStatement',
    TaggedTemplateExpression: 'TaggedTemplateExpression',
    TemplateLiteral: 'TemplateLiteral',
    BlockStatement: 'BlockStatement',
    TemplateElement: 'TemplateElement',
    ClassProperty: 'ClassProperty',
    ObjectExpression: 'ObjectExpression',
    KeyValueProperty: 'KeyValueProperty',
    TsTypeAnnotation: 'TsTypeAnnotation',
    TsTypeReference: 'TsTypeReference',
    ExportDeclaration: 'ExportDeclaration',
    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
    ExportDefaultExpression: 'ExportDefaultExpression',
    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
    AssignmentExpression: 'AssignmentExpression',
    ArrayExpression: 'ArrayExpression',
    VariableDeclaration: 'VariableDeclaration',
    VariableDeclarator: 'VariableDeclarator',
    Constructor: 'Constructor',
    Parameter: 'Parameter',
    NullLiteral: 'NullLiteral',
    Super: 'Super',
    ParenthesisExpression: 'ParenthesisExpression',
    ArrowFunctionExpression: 'ArrowFunctionExpression'
});
function isParenthesisExpression(node) {
    return node?.type === TYPES.ParenthesisExpression;
}
function isArrowFunctionExpression(node) {
    return node?.type === TYPES.ArrowFunctionExpression;
}
function isSuper(node) {
    return node?.type === TYPES.Super;
}
function isExportDefaultDeclaration(node) {
    return node?.type === TYPES.ExportDefaultDeclaration;
}
function isVariableDeclarator(node) {
    return node?.type === TYPES.VariableDeclarator;
}
function isVariableDeclaration(node) {
    return node?.type === TYPES.VariableDeclaration;
}
function isExportDefaultExpression(node) {
    return node?.type === TYPES.ExportDefaultExpression;
}
function isExportDeclaration(node) {
    return node?.type === TYPES.ExportDeclaration;
}
function isImportDeclaration(node) {
    return node?.type === TYPES.ImportDeclaration;
}
function isClasDeclaration(node) {
    return node?.type === TYPES.ClassDeclaration;
}
function isDecorator(node) {
    return node?.type === TYPES.Decorator;
}
function isCallExpression(node) {
    return node?.type === TYPES.CallExpression;
}
function isStringLiteral(node) {
    return node?.type === TYPES.StringLiteral;
}
function isClassMethod(node) {
    return node?.type === TYPES.ClassMethod;
}
function isIdentifer(node) {
    return node?.type === TYPES.Identifier;
}
function isImportSpecifier(node) {
    return node?.type === TYPES.ImportSpecifier;
}
function isImportDefaultSpecifier(node) {
    return node?.type == TYPES.ImportDefaultSpecifier;
}
function isMemberExpression(node) {
    return node?.type === TYPES.MemberExpression;
}
function isExpressionStatement(node) {
    return node?.type === TYPES.ExpressionStatement;
}
function isReturnStatement(node) {
    return node?.type === TYPES.ReturnStatement;
}
function isTaggedTemplateExpression(node) {
    return node?.type === TYPES.TaggedTemplateExpression;
}
function isTemplateLiteral(node) {
    return node?.type === TYPES.TemplateLiteral;
}
function isTemplateElement(node) {
    return node?.type === TYPES.TemplateElement;
}
function isBlockStatement(node) {
    return node?.type === TYPES.BlockStatement;
}
function isClassProperty(node) {
    return node?.type === TYPES.ClassProperty;
}
function isObjectExpression(node) {
    return node?.type === TYPES.ObjectExpression;
}
function isKeyValueProperty(node) {
    return node?.type === TYPES.KeyValueProperty;
}
function isTsTypeAnnotation(node) {
    return node?.type === TYPES.TsTypeAnnotation;
}
function isTsTypeReference(node) {
    return node?.type === TYPES.TsTypeReference;
}
function isAssignmentExpression(node) {
    return node?.type === TYPES.AssignmentExpression;
}
function isArrayExpression(node) {
    return node?.type === TYPES.ArrayExpression;
}
function isConstructor(node) {
    return node?.type === TYPES.Constructor;
}
function isParameter(node) {
    return node?.type === TYPES.Parameter;
}
function isNullLiteral(node) {
    return node?.type === TYPES.NullLiteral;
}

exports.TYPES = TYPES;
exports.createArrayExpression = createArrayExpression;
exports.createAssignmentExpression = createAssignmentExpression;
exports.createBlockStatement = createBlockStatement;
exports.createCallExpression = createCallExpression;
exports.createClassExpression = createClassExpression;
exports.createClassProperty = createClassProperty;
exports.createConstructor = createConstructor;
exports.createDecorator = createDecorator;
exports.createExportDefaultClassExpression = createExportDefaultClassExpression;
exports.createExportDefaultDeclaration = createExportDefaultDeclaration;
exports.createExportDefaultExpression = createExportDefaultExpression;
exports.createExpressionStatement = createExpressionStatement;
exports.createFunction = createFunction;
exports.createGetter = createGetter;
exports.createIdentifer = createIdentifer;
exports.createImportDeclaration = createImportDeclaration;
exports.createImportDefaultSpecifier = createImportDefaultSpecifier;
exports.createImportSpecifier = createImportSpecifier;
exports.createKeyValueProperty = createKeyValueProperty;
exports.createMemberExpression = createMemberExpression;
exports.createNamedImportSpecifier = createNamedImportSpecifier;
exports.createNullLiteral = createNullLiteral;
exports.createObjectExpression = createObjectExpression;
exports.createOptionalChainingExpression = createOptionalChainingExpression;
exports.createReturnStatement = createReturnStatement;
exports.createSpan = createSpan;
exports.createStringLiteral = createStringLiteral;
exports.createSuper = createSuper;
exports.createTaggedTemplateExpression = createTaggedTemplateExpression;
exports.createTemplateElement = createTemplateElement;
exports.createTemplateLiteral = createTemplateLiteral;
exports.createThisExpression = createThisExpression;
exports.createVariableDeclaration = createVariableDeclaration;
exports.createVariableDeclarator = createVariableDeclarator;
exports.isArrayExpression = isArrayExpression;
exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.isAssignmentExpression = isAssignmentExpression;
exports.isBlockStatement = isBlockStatement;
exports.isCallExpression = isCallExpression;
exports.isClasDeclaration = isClasDeclaration;
exports.isClassMethod = isClassMethod;
exports.isClassProperty = isClassProperty;
exports.isConstructor = isConstructor;
exports.isDecorator = isDecorator;
exports.isExportDeclaration = isExportDeclaration;
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
exports.isExportDefaultExpression = isExportDefaultExpression;
exports.isExpressionStatement = isExpressionStatement;
exports.isIdentifer = isIdentifer;
exports.isImportDeclaration = isImportDeclaration;
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.isImportSpecifier = isImportSpecifier;
exports.isKeyValueProperty = isKeyValueProperty;
exports.isMemberExpression = isMemberExpression;
exports.isNullLiteral = isNullLiteral;
exports.isObjectExpression = isObjectExpression;
exports.isParameter = isParameter;
exports.isParenthesisExpression = isParenthesisExpression;
exports.isReturnStatement = isReturnStatement;
exports.isStringLiteral = isStringLiteral;
exports.isSuper = isSuper;
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
exports.isTemplateElement = isTemplateElement;
exports.isTemplateLiteral = isTemplateLiteral;
exports.isTsTypeAnnotation = isTsTypeAnnotation;
exports.isTsTypeReference = isTsTypeReference;
exports.isVariableDeclaration = isVariableDeclaration;
exports.isVariableDeclarator = isVariableDeclarator;
exports.updateImportDeclaration = updateImportDeclaration;
