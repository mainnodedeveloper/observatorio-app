import { Visitor } from '@swc/core/Visitor.js';
import { dirname, extname, join } from 'path';
import { createArrayExpression, createExpressionStatement, createIdentifer, createImportDefaultSpecifier, createKeyValueProperty, createSpan, createStringLiteral, } from 'swc-ast-helpers';
const randomIdentifier = () => Math.random().toString(36).substring(2, 15).replace(/\d/g, '');
const isComponentDecorator = (decorator) => decorator.expression.type === 'CallExpression' &&
    (decorator.expression?.callee).value === 'Component';
export class AngularComponents extends Visitor {
    options;
    importFiles = [];
    constructor(options) {
        super();
        this.options = options;
    }
    visitTsTypes(nodes) {
        return nodes;
    }
    visitTsType(nodes) {
        return nodes;
    }
    visitModuleItems(items) {
        const files = [...items.flatMap(item => this.visitModuleItem(item))];
        if (this.importFiles.length) {
            for (const { url, identifier } of this.importFiles) {
                files.unshift({
                    type: 'ImportDeclaration',
                    span: createSpan(),
                    typeOnly: false,
                    specifiers: [createImportDefaultSpecifier(identifier)],
                    source: createStringLiteral(url),
                });
            }
        }
        return files;
    }
    visitDecorator(decorator) {
        if (!isComponentDecorator(decorator))
            return decorator;
        const componentOptions = decorator.expression
            .arguments[0].expression;
        //@ts-ignore
        decorator.expression.arguments = [
            {
                expression: {
                    ...componentOptions,
                    properties: componentOptions.properties.map(prop => {
                        switch (prop.key.value) {
                            case 'styleUrls': {
                                return this.transformStyleUrls(prop);
                            }
                            case 'templateUrl': {
                                return this.transformTemplateUrl(prop);
                            }
                            default:
                                return prop;
                        }
                    }),
                },
            },
        ];
        return decorator;
    }
    transformTemplateUrl(prop) {
        const templateUrl = prop.value.value;
        const actualImportPath = join(dirname(this.options.sourceUrl), templateUrl);
        if (extname(actualImportPath) !== '.html') {
            throw new Error(`HTML type ${extname(actualImportPath)} is not supported.`);
        }
        const identifier = randomIdentifier();
        this.importFiles.push({
            identifier,
            url: templateUrl + '?raw',
        });
        return createKeyValueProperty(createIdentifer('template'), createIdentifer(identifier));
    }
    transformStyleUrls(prop) {
        const styleUrls = prop.value;
        const styles = styleUrls.elements.map(e => {
            const styleUrl = e.expression.value;
            const identifier = randomIdentifier();
            this.importFiles.push({
                url: styleUrl + '?inline',
                identifier,
            });
            return identifier;
        });
        return {
            ...prop,
            key: createIdentifer('styles'),
            value: createArrayExpression(styles.map(c => createExpressionStatement(createIdentifer(c)))),
        };
    }
}
